<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 3 Write-Up</h1>
		<div style="text-align: center;">Names: Yun Chung and Sebastian Mejia </div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-la-celeste-website">cal-cs184-student.github.io/hw-webpages-la-celeste-website</a>
		<br>
		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw3-fiat-lux">github.com/cal-cs184-student/sp25-hw3-fiat-lux</a>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		<p>
		  <b>
		    Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.
		  </b>
		</p>

		<h2>Part 1: Ray Generation and Scene Intersection</h2>

		<p>
		  <b>
		    Walk through the ray generation and primitive intersection parts of the rendering pipeline.
		  </b>
		</p>

		<p>
		  We implemented raytracing with a for loop that iterates over the number of random samples (ns_aa) of some pixel (x, y) in the image.
		  After we normalize the x and y values over the image's dimensions, we compute the radiance of each sampled ray. We then get the sum of radiances
		  and divide it by the number of samples to get the average estimated radiance, which is then written to the sample buffer after updating the pixel
		  with the average radiance color.
		</p>

		<p>
		  <b>
		    Explain the triangle intersection algorithm you implemented in your own words.
		  </b>
		</p>

		<p>
		  The triangle intersection algorithm was pretty much based off the Möller-Trumbore Algorithm as described in Lecture 9-10, slide 21.
		  If the ray's direction is parallel to the triangle, there is no intersection (S1 * E1 == 0).
		  We calculate Barycentric coordinates as shown in the diagram from lecture, and use those along with r.min_t and r.max_t to test for intersection.
		</p>

		<figure>
	        <img
	          src="./images/Möller-Trumbore.png"
	          style="width: 50%"
	          />
	        </figure>

		<p>
		  <b>
		    Show images with normal shading for a few small .dae files.
		  </b>
		</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="images/CBempty.png" width="400px"/>
				  <figcaption>Room rendering.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="images/CBspheres.png" width="400px"/>
				  <figcaption>Room with spheres rendering.</figcaption>
				</td>
			  </tr>
			</table>
		</div>.

		<h2>Part 2: Bounding Volume Hierarchy</h2>
			
		<p>
		  <b>
		    Walk through your BVH construction algorithm. Explain the heuristic you chose for picking the splitting point.
		  </b>
		</p>

		<p>
		  Our BVH construction algorithm constructs a binary tree where each node has a bounding box, which we expanded as necessary.
		  If the current node has less than <code>max_leaf_size</code> primitives, then it's a leaf node. We give it iterators to the start and end of its primitives, and return.
		  Afterwards, we handle the internal node case. We select the splitting axis based on the bounding box's largest dimension.
		  Our splitting heuristic is a median split; we divide primitives in half with <code>midpoint = start + (n / 2)</code>. This ensures that the tree is balanced.
		</p>

		<p>
		  <b>
		    Show images with normal shading for a few large .dae files that you can only render with BVH acceleration.
		  </b>
		</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
		  <table style="width: 100%; text-align: center; border-collapse: collapse;">
		    <tr>
		      <td style="text-align: center;">
	                <img src="images/wall-e.png" width="400px"/>
			<figcaption>"Eva ❤️"</figcaption>
		      </td>
		      <td style="text-align: center;">
		        <img src="images/dragon.png" width="400px"/>
		        <figcaption>"Rawr"</figcaption>
		      </td>
		    </tr>
		  </table>
		</div>.

		<p>
		  <b>
		    Compare rendering times on a few scenes with moderately complex geometries with and without BVH acceleration. Present your results in a one-paragraph analysis.
		  </b>
		</p>

		<p>
		  As you can see in the images below, implementing BVH substantially sped up the rendering runtime. It appears that the BVH implementation spends SLIGHTLY more time
		  on collecting primitives and building the BVH (since this isn't relevant to the non-BVH implementation). The BVH implementation took roughly 1/100th of the time
		  to render, its average speed was roughly 100 times faster, and it averaged roughly 150 times less intersection tests per ray.
		</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
		  <table style="width: 100%; text-align: center; border-collapse: collapse;">
		    <tr>
		      <td style="text-align: center;">
	                <img src="images/before_bvh.png" width="400px"/>
			<figcaption>Stats before BVH.</figcaption>
		      </td>
		      <td style="text-align: center;">
		        <img src="images/after_bvh.png" width="400px"/>
		        <figcaption>Stats after BVH.</figcaption>
		      </td>
		    </tr>
		  </table>
		</div>.

		<h2>Part 3: Direct Illumination</h2>
		Lorem ipsu

		<h2>Part 4: Global Illumination</h2>
		Loident, sunt in culpa m.

		<h2>Part 5: Adaptive Sampling</h2>

		<h2>(Optional) Part 6: Extra Credit Opportunities</h2>
		
		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>
